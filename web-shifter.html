<!--
    - add external scripts to be loaded (Player, Walls, etc)
    - add JSON ascii lvl maps + parsing function
    - create Background object
    - change player/wall color settings to match BG and to work with colorShift methods? (or not?)
    - change all color formats from RGB to RGBA
    - make initial color param for color simple RGBA string, not individual arguments for hues
        then add parser to break down into individual hue properties
    - DONT USE SPACES WITH COLORS   not this: 'rgb(200, 200, 200)', this: 'rgb(200,200,200)'
    - choose between having clrChange method in all objects, or just having the colorShift method change properties
        and having the color string continually update in the object

    - create Shifter object w/ methods inside
    - create separate method for changing text color

    - only allow control of game when canvas is in focus
    - BUG: event handler only checks firsts key / doesn't accept OR statements?
-->

<!DOCTYPE html>
<html lang='en'>
    <head>
        <meta charset='utf-8'>
        <meta name='viewport' content='width=device-width, initial-scale=1.0'>
        <title>Warmup</title>
        <style>
            * {
                margin: 0;
                padding: 0;
            }
            html {
                font-size: 10px;
                font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            }

            body {
                color: #300;
                overflow: hidden;
            }

            h1 {
                position: absolute;
                left: 30px;
                font-size: 6rem;
                color: rgba(0,0,0,0.5);
            }

            canvas {
                width: 512px;
                height: 512px;
                display: block;
                margin: 0 auto;
                margin-top: 20px;
            }
        </style>
        <script>
            document.addEventListener('DOMContentLoaded', function() {
                const header = document.querySelector('h1');
                const canvas = document.querySelector('canvas');
                const ctx = canvas.getContext('2d');
                var canWidth = canvas.width; // = window.outerWidth;
                var canHeight = canvas.height; // = window.outerHeight;
                // get diagonal width of canvas
                var canDiag = (canWidth + canHeight) / 2;
                // set tile size
                var TS = canHeight / 16;

                var leftPressed = false;
                var rightPressed = false;
                var upPressed = false;
                var downPressed = false;

                document.addEventListener('keydown', keyDownHandler, false);
                document.addEventListener('keyup', keyUpHandler, false);

                var BGColor = {
                    r:0, g: 0, b:0,

                    getString: function() {
                        return 'rgb(' + this.r + ',' 
                            + this.g + ',' + this.b + ')';
                    },

                    changeClr: function(hue, value) {
                        switch(hue) {
                            case 'all': this.r = this.g = this.b = value; break;
                            case 'r': this.r = value; break;
                            case 'g': this.g = value; break;
                            case 'b': this.b = value; break;
                            default: break;
                        }
                    }
                }

                function Player(x, y, width, height, speed, color) {
                    this.x = x; 
                    this.y = y; 
                    this.width = width; this.height = height;

                    this.speed = speed;
                    this.slideSpeed = 1; // speed during move assist

                    // color must be rbga!
                    this.color = color;
                    this.r = 0;
                    this.g = 0;
                    this.b = 0;

                    // break color string into individual hue properties
                    this.breakString = function() {
                        var tempString = this.color.replace('rgb(', '');
                        tempString = tempString.replace(')', '');
                        tempString = tempString.split(',');
                        this.r = tempString[0];
                        this.g = tempString[1];
                        this.b = tempString[2];
                    }
                    // apply at the start to initialize hue properties
                    this.breakString();

                    // get usable color string of RGB properties
                    this.getString = function() {
                        return 'rgb(' + this.r + ',' 
                            + this.g + ',' + this.b + ')';
                    }

                    this.changeClr =  function(hue, value) {
                        switch(hue) {
                            case 'all': this.r = this.g = this.b = value; break;
                            case 'r': this.r = value; break;
                            case 'g': this.g = value; break;
                            case 'b': this.b = value; break;
                            default: break;
                        }
                        // apply changes to main color string
                        this.color = this.getString();
                    }

                    this.draw = function() {
                        // apply any color changes
                        this.color = this.getString();
                        // draw rect
                        ctx.beginPath();
                        ctx.fillStyle = this.color;
                        ctx.fillRect(this.x, this.y, this.width, this.height);
                    }

                    this.update = function() {
                        // for strange reasons, collision seems to only work if
                        //    x/y coordinates are checked for collision independantly

                        // apply x velocity and check horizontal collisions
                        this.x += (rightPressed - leftPressed) * speed;
                        // check wall collisions
                        if (walls) {
                            for (var w=0; w<walls.length; w++) {
                                var wall = walls[w];
                                if (this.x < wall.x + wall.width &&
                                    this.x + this.width > wall.x &&
                                    this.y < wall.y + wall.height &&
                                    this.y + this.height > wall.y) {
                                    if (rightPressed) {
                                        this.x = wall.x - this.width;

                                        // crawl along wall if close enough to edge / touching corner of wall (move assist)
                                        // make sure that RIGHT is the only key being pressed
                                        if (this.y < wall.y && !upPressed &&
                                            !upPressed && !downPressed) {
                                            this.y -= this.slideSpeed;
                                        } else if ( this.y + this.height > wall.y + wall.height
                                                    && !downPressed) {
                                            this.y += this.slideSpeed;
                                        }
                                    } else if (leftPressed) {
                                        this.x = wall.x + wall.width;

                                        if (this.y < wall.y && !rightPressed &&
                                            !upPressed && !downPressed) {
                                            this.y -= this.slideSpeed;
                                        } else if ( this.y + this.height > wall.y + wall.height
                                                    && !downPressed) {
                                            this.y += this.slideSpeed;
                                        }
                                    }
                                }
                            }
                        }

                        // apply y velocity and check vertical collisions
                        // *only seems to work if collision is checked again
                        this.y += (downPressed - upPressed) * speed;
                        if (walls) {
                            for (var w=0; w<walls.length; w++) {
                                var wall = walls[w];
                                if (this.x < wall.x + wall.width &&
                                    this.x + this.width > wall.x &&
                                    this.y < wall.y + wall.height &&
                                    this.y + this.height > wall.y) {
                                    if (downPressed) {
                                        this.y = wall.y - this.height;
                                        // check for move assist when pushing down on CORNER of wall
                                        // make sure DOWN is the only key being pressed
                                        if (this.x < wall.x && !upPressed &&
                                            !leftPressed && !rightPressed) {
                                            this.x -= this.slideSpeed;
                                        } else if (this.x+this.width > wall.x+wall.width) {
                                            this.x += this.slideSpeed;
                                        }
                                    } else if (upPressed) {
                                        this.y = wall.y + wall.height;
                                        // check for move assist when pushing up
                                        if (this.x < wall.x && !downPressed &&
                                            !leftPressed && !rightPressed) {
                                            this.x -= this.slideSpeed;
                                        } else if (this.x+this.width > wall.x+wall.width) {
                                            this.x += this.slideSpeed;
                                        }
                                    }
                                }
                            }
                        }

                        // check screen bounds
                        if(this.x < 0) {
                            this.x = 0
                        } else if(this.x > canWidth-this.width) {
                            this.x = canWidth - this.width;
                        }
                        if(this.y < 0) {
                            this.y = 0;
                        } else if(this.y > canHeight-this.height) {
                            this.y = canHeight - this.height;
                        }
                    }
                }

                function Wall(x, y, width, height, color) {
                    this.x = x;
                    this.y = y;
                    this.width = width;
                    this.height = height;
                    
                    this.color = color;
                    this.r = 0;
                    this.g = 0;
                    this.b = 0;

                    // break color string into individual hue properties
                    this.breakString = function() {
                        var tempString = this.color.replace('rgb(', '');
                        tempString = tempString.replace(')', '');
                        tempString = tempString.split(',');
                        this.r = tempString[0];
                        this.g = tempString[1];
                        this.b = tempString[2];
                    }
                    // apply at the start to initialize hue properties
                    this.breakString();

                    this.getString = function() {
                        this.color = 'rgb(' + this.r + ',' 
                            + this.g + ',' + this.b + ')';
                        //console.log(this.color);
                    }

                    this.changeClr =  function(hue, value) {
                        switch(hue) {
                            case 'all': this.r = this.g = this.b = value; break;
                            case 'r': this.r = value; break;
                            case 'g': this.g = value; break;
                            case 'b': this.b = value; break;
                            default: break;
                        }
                        // apply changes to main color string
                        this.color = this.getString();
                        //console.log(this.color);
                    }

                    this.draw = function() {
                        ctx.beginPath();
                        ctx.fillStyle = this.color;
                        ctx.fillRect(this.x, this.y, this.width, this.height);
                    }
                }

                // uncomment to add mouse movement (negates wall collision  )
                /*
                onmousemove = function() {
                    player.x = event.clientX;
                    player.y = event.clientY;
                }
                */

                function keyDownHandler(event) {
                    switch(event.key) {
                        case 'ArrowRight' || 'right'  || 'd':
                            rightPressed = true;
                            break;
                        case 'ArrowLeft' || 'left' || 'a':
                            leftPressed = true;
                            break;
                        case 'ArrowDown' || 'down' || 's':
                            downPressed = true;
                            break;
                        case 'ArrowUp' || 'up' || 'w':
                            upPressed = true;
                            break;
                        default:
                            break;
                    }
                }

                function keyUpHandler(event) {
                    switch(event.key) {
                        case 'ArrowRight' || 'right' || 'd':
                            rightPressed = false;
                            break;
                        case 'ArrowLeft' || 'left' || 'a':
                            leftPressed = false;
                            break;
                        case 'ArrowDown' || 'down' || 's':
                            downPressed = false;
                            break;
                        case 'ArrowUp' || 'up' || 'w':
                            upPressed = false;
                            break;
                        default:
                            break;
                    }
                }

                /*  
                    shiftClr() changes the color values of a given subject
                    based on the position of a given object

                    Subject MUST have x/y properties, 
                    and object MUST have r/g/b properties
                */
                function shiftClr(subject, object, axis, hue, reversed) {
                    // get new color value based on object position and axis
                    var value;
                    switch(axis) {
                        case 'x': 
                            // If reversed, the given hue brightness is affected inversly
                            if(reversed) {
                                value = 255 - (255*(subject.x/canWidth));
                            } else {
                                value = 255 * (subject.x/canWidth);
                            }
                            break;
                        
                        case 'y':
                            if(reversed) {
                                value = 255 - (255*(subject.y/canHeight));
                            } else {
                                value = 255 * (subject.y/canHeight);
                            }
                            break;
                        
                        case 'xy':
                            if(reversed) {
                                value = 255 - (255*((subject.x+subject.y)/2) 
                                    / canDiag);
                            } else {
                                value = 255 * ((subject.x+subject.y)/2)
                                    / canDiag;
                            }
                            break;
                        
                        default: value = 0; 
                            break;
                    }
                    // apply color change to target
                    object.changeClr(hue, value);
                    /*
                    switch(hue) {
                        case 'all': object.r = object.g = object.b = value; break;
                            case 'r': object.r = value; break;
                            case 'g': object.g = value; break;
                            case 'b': object.b = value; break;
                            default: break;
                    }
                    */
                }

                function update() {
                    shiftClr(player, BGColor, 'x', 'b', true);
                    shiftClr(player, BGColor, 'y', 'r', false);

                    shiftClr(player, player, 'x', 'b', false);
                    shiftClr(player, player, 'y', 'r', true);

                    header.style.color = 'rgba(' +
                        255 * (player.x / canWidth) + ',' +
                        255 * (player.x / canWidth) + ',' +
                        255 * (player.x / canWidth) + ')';

                    player.update();
                    // draw background
                    ctx.beginPath();
                    ctx.fillStyle = BGColor.getString();
                    ctx.fillRect(0, 0, canWidth, canHeight);

                    // draw walls
                    for (var i=0; i<walls.length; i++) {
                        // test color shift
                        //shiftClr(player, walls[i], 'x', 'r', true);

                        walls[i].draw();
                    }

                    // draw player
                    player.draw();
                }

                // IMPORTANT: make player slightly smaller in order to fit between gaps
                var player = new Player(0, 0, TS*0.95, TS*0.95, 3, 'rgb(0,0,0)');
                var walls = [];
                walls.push(new Wall(TS*3, TS*3, TS, TS, 'rgb(0,0,0)'));
                walls.push(new Wall(TS*3, TS*5, TS, TS, '#rgb(0,0,0)'));
                walls.push(new Wall(TS*3, TS*6, TS, TS, '#rgb(0,0,0)'));

                walls.push(new Wall(TS*5, TS*3, TS, TS, '#rgb(0,0,0)'));
                walls.push(new Wall(TS*6, TS*3, TS, TS, '#rgb(0,0,0)'));


                // start loop
                setInterval(update, 10);
            });
        </script>
    </head>
    <body>
        <h1>SHIFTER</h1>
        <canvas width='512' height='512'>
            <p>Failed to load canvas.</p>
        </canvas>
    </body>
</html>