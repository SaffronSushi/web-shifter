<!--
    ADD BUTTONS TO SCREEN TO CONTROL SHIFT PROPERTIES
-->

<!DOCTYPE html>
<html lang='en'>
    <head>
        <meta charset='utf-8'>
        <meta name='viewport' content='width=device-width, initial-scale=1.0'>
        <title>Warmup</title>
        <style>
            * {
                margin: 0;
                padding: 0;
            }
            html {
                font-size: 10px;
                font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            }

            body {
                color: #300;
                overflow: hidden;
            }

            canvas {
                width: 512px;
                height: 512px;
                display: block;
                margin: 0 auto;
                margin-top: 20px;
            }
        </style>
        <script>
            document.addEventListener('DOMContentLoaded', function() {
                const canvas = document.querySelector('canvas');
                const ctx = canvas.getContext('2d');
                var canWidth = canvas.width; // = window.outerWidth;
                var canHeight = canvas.height; // = window.outerHeight;
                // get diagonal width of canvas
                var canDiag = (canWidth + canHeight) / 2;
                // set tile size
                var TS = canHeight / 16;

                var leftPressed = false;
                var rightPressed = false;
                var upPressed = false;
                var downPressed = false;

                document.addEventListener('keydown', keyDownHandler, false);
                document.addEventListener('keyup', keyUpHandler, false);

                var BGColor = {
                    r:0, g: 0, b:0,

                    getString: function() {
                        return 'rgb(' + this.r + ',' 
                            + this.g + ',' + this.b + ')';
                    },

                    changeClr: function(hue, value) {
                        switch(hue) {
                            case 'all': this.r = this.g = this.b = value; break;
                            case 'r': this.r = value; break;
                            case 'g': this.g = value; break;
                            case 'b': this.b = value; break;
                            default: break;
                        }
                    }
                }

                function Player(x, y, width, height, speed, color) {
                    this.x = x; 
                    this.y = y; 
                    this.width = width; this.height = height;
                    this.color = color;

                    this.speed = speed;
                    this.dx = 0;
                    this.dy = 0;

                    this.draw = function() {
                        ctx.beginPath();
                        ctx.fillStyle = this.color;
                        ctx.fillRect(this.x, this.y, this.width, this.height);
                    }

                    this.update = function() {
                        // for strange reasons, collision seems to only work if
                        //    x/y coordinates are checked for collision independantly

                        // apply x velocity and check horizontal collisions
                        this.x += (rightPressed - leftPressed) * speed;
                        // check wall collisions
                        if (this.x < wall.x + wall.width &&
                            this.x + this.width > wall.x &&
                            this.y < wall.y + wall.height &&
                            this.y + this.height > wall.y) {
                            if (rightPressed) {
                                this.x = wall.x - this.width;

                                // crawl along wall if close enough to edge (move assist)
                                if (this.y < wall.y && !upPressed) {
                                    this.y -= 1;
                                } else if ( this.y + this.height > wall.y + wall.height
                                            && !downPressed) {
                                    this.y += 1;
                                }
                            } else {
                                this.x = wall.x + wall.width;

                                if (this.y < wall.y && !upPressed) {
                                    this.y -= 1;
                                } else if ( this.y + this.height > wall.y + wall.height
                                            && !downPressed) {
                                    this.y += 1;
                                }
                            }
                        }

                        // apply y velocity and check vertical collisions
                        this.y += (downPressed - upPressed) * speed;
                        if (this.x < wall.x + wall.width &&
                            this.x + this.width > wall.x &&
                            this.y < wall.y + wall.height &&
                            this.y + this.height > wall.y) {
                            if (downPressed) {
                                this.y = wall.y - this.height;
                            } else {
                                this.y = wall.y + wall.height;
                            }
                        }

                        // check screen bounds
                        if(this.x < 0) {
                            this.x = 0
                        } else if(this.x > canWidth-this.width) {
                            this.x = canWidth - this.width;
                        }
                        if(this.y < 0) {
                            this.y = 0;
                        } else if(this.y > canHeight-this.height) {
                            this.y = canHeight - this.height;
                        }
                    }
                }

                function Wall(x, y, width, height, r, g, b) {
                    this.x = x;
                    this.y = y;
                    this.width = width;
                    this.height = height;
                    
                    this.r = r;
                    this.g = g;
                    this.b = b;
                    this.color = '#000';

                    this.getString = function() {
                        this.color = 'rgb(' + this.r + ',' 
                            + this.g + ',' + this.b + ')';
                    },

                    this.draw = function() {
                        ctx.beginPath();
                        ctx.fillStyle = this.color;
                        ctx.fillRect(this.x, this.y, this.width, this.height);
                    }
                }

                onmousemove = function() {
                    player.x = event.clientX;
                    player.y = event.clientY;
                }

                function keyDownHandler(event) {
                    switch(event.key) {
                        case 'ArrowRight' || 'right':
                            rightPressed = true;
                            break;
                        case 'ArrowLeft' || 'left':
                            leftPressed = true;
                            break;
                        case 'ArrowDown' || 'down':
                            downPressed = true;
                            break;
                        case 'ArrowUp' || 'up':
                            upPressed = true;
                            break;
                        default:
                            break;
                    }
                }

                function keyUpHandler(event) {
                    switch(event.key) {
                        case 'ArrowRight' || 'right':
                            rightPressed = false;
                            break;
                        case 'ArrowLeft' || 'left':
                            leftPressed = false;
                            break;
                        case 'ArrowDown' || 'down':
                            downPressed = false;
                            break;
                        case 'ArrowUp' || 'up':
                            upPressed = false;
                            break;
                        default:
                            break;
                    }
                }

                /*  
                    shiftClr() changes the color values of a given subject
                    based on the position of a given object

                    Subject MUST have x/y properties, 
                    and object MUST have r/g/b properties
                */
                function shiftClr(subject, object, axis, hue, reversed) {
                    // get new color value based on object position and axis
                    var value;
                    switch(axis) {
                        case 'x': 
                            // If reversed, the given hue brightness is affected inversly
                            if(reversed) {
                                value = 255 - (255*(subject.x/canWidth));
                            } else {
                                value = 255 * (subject.x/canWidth);
                            }
                            break;
                        
                        case 'y':
                            if(reversed) {
                                value = 255 - (255*(subject.y/canHeight));
                            } else {
                                value = 255 * (subject.y/canHeight);
                            }
                            break;
                        
                        case 'xy':
                            if(reversed) {
                                value = 255 - (255*((subject.x+subject.y)/2) 
                                    / canDiag);
                            } else {
                                value = 255 * ((subject.x+subject.y)/2)
                                    / canDiag;
                                console.log(value);
                            }
                            break;
                        
                        default: value = 0; 
                            break;
                    }
                    // apply color change to target
                    switch(hue) {
                        case 'all': object.r = object.g = object.b = value; break;
                            case 'r': object.r = value; break;
                            case 'g': object.g = value; break;
                            case 'b': object.b = value; break;
                            default: break;
                    }
                }

                function update() {
                    shiftClr(player, BGColor, 'x', 'b', true);
                    shiftClr(player, BGColor, 'y', 'r', false);
                    player.update();
                    // draw background
                    ctx.beginPath();
                    ctx.fillStyle = BGColor.getString();
                    ctx.fillRect(0, 0, canWidth, canHeight);

                    // draw walls
                    wall.draw();

                    // draw player
                    player.draw();
                }

                var player = new Player(0, 0, TS, TS, 3, '#faa');
                //var walls = [];
                var wall = new Wall(TS*3, TS*3, TS, TS*5, '#000');

                // start loop
                setInterval(update, 10);
            });
        </script>
    </head>
    <body>
        <canvas width='512' height='512'>
            <p>Failed to load canvas.</p>
        </canvas>
    </body>
</html>